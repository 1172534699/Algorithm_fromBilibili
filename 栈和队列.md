### 栈和队列

|  Part I   |   Part II   |
| :-------: | :---------: |
| [栈](#p1) | [队列](#p2) |

<span id="p1">**栈**</span>

**1-顺序栈**

*顺序栈的定义*

~~~cpp
struct SqStack
{
    ElemType *base;
    ElemType *top;
    int stacksize;
};
~~~

*顺序栈的初始化*

~~~cpp
bool InitStack(SqStack &S)
{
    S.base = new ElemType[MAXSIZE];
    if (!S.base)
    {
        cerr << "failed to get memory" << endl;
        return false;
    }
    S.top = S.base;
    S.stacksize = MAXSIZE;
    return true;
}
~~~

*压栈*

~~~cpp 
bool Push(SqStack &S, ElemType &e)
{
    //判断栈是否已满
    if((S.top-S.base) == S.stacksize)
    {
        cerr << "full of stack" << endl;
        return false;
    }
    *(S.top) = e;
    ++(S.top);
    return true;
}
~~~

*创建一个栈*

~~~cpp
bool CreatStack(SqStack &S, const int n)
{
    for (int i = 0; i < n;++i)
    {
        ElemType input;
        cin >> input;
        if(!Push(S,input))
        {
            cerr << "error happend at-" << i << endl;
            return false;
        }
    }
    return true;
}
~~~

*弹栈*

~~~cpp
bool Pop(SqStack &S, ElemType &e)
{
    if(!IsEmpty(S))
    {
        cerr << "empty stack!error" << endl;
        return false;
    }
    --(S.base);
    e = *(S.base);
    return true;
}
~~~

*判断顺序栈是否为空*

~~~cpp
bool IsEmpty(SqStack &S)
{
    if (S.base == S.top)
    {
        return true;
    }
    else
    {
        return false;
    }
}
~~~

*获取栈的元素个数*

~~~cpp
int StackLength(SqStack &S)
{
    return static_cast<int>(S.top - S.base);
}
~~~

*清空顺序栈*

~~~cpp
bool ClearStack(SqStack &S)
{
    if(S.base)
    {
        S.top = S.base;
        return true;
    }
    else
    {
        return false;
    }
}
~~~

*销毁顺序栈*

~~~cpp
void DestoyStack(SqStack &S)
{
    if(S.base)
    {
        delete[] S.base;
        S.stacksize = 0;
        S.base = S.top = nullptr;
    }
}
~~~


