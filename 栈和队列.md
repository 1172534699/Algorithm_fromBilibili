### 栈和队列

|  Part I   |   Part II   |
| :-------: | :---------: |
| [栈](#p1) | [队列](#p2) |

<span id="p1">**栈**</span>

**1-顺序栈**

*顺序栈的定义*

~~~cpp
struct SqStack
{
    ElemType *base;
    ElemType *top;
    int stacksize;
};
~~~

*顺序栈的初始化*

~~~cpp
bool InitStack(SqStack &S)
{
    S.base = new ElemType[MAXSIZE];
    if (!S.base)
    {
        cerr << "failed to get memory" << endl;
        return false;
    }
    S.top = S.base;
    S.stacksize = MAXSIZE;
    return true;
}
~~~

*压栈*

~~~cpp 
bool Push(SqStack &S, ElemType &e)
{
    //判断栈是否已满
    if((S.top-S.base) == S.stacksize)
    {
        cerr << "full of stack" << endl;
        return false;
    }
    *(S.top) = e;
    ++(S.top);
    return true;
}
~~~

*创建一个栈*

~~~cpp
bool CreatStack(SqStack &S, const int n)
{
    for (int i = 0; i < n;++i)
    {
        ElemType input;
        cin >> input;
        if(!Push(S,input))
        {
            cerr << "error happend at-" << i << endl;
            return false;
        }
    }
    return true;
}
~~~

*弹栈*

~~~cpp
bool Pop(SqStack &S, ElemType &e)
{
    if(!IsEmpty(S))
    {
        cerr << "empty stack!error" << endl;
        return false;
    }
    --(S.base);
    e = *(S.base);
    return true;
}
~~~

*判断顺序栈是否为空*

~~~cpp
bool IsEmpty(SqStack &S)
{
    if (S.base == S.top)
    {
        return true;
    }
    else
    {
        return false;
    }
}
~~~

*获取栈的元素个数*

~~~cpp
int StackLength(SqStack &S)
{
    return static_cast<int>(S.top - S.base);
}
~~~

*清空顺序栈*

~~~cpp
bool ClearStack(SqStack &S)
{
    if(S.base)
    {
        S.top = S.base;
        return true;
    }
    else
    {
        return false;
    }
}
~~~

*销毁顺序栈*

~~~cpp
void DestoyStack(SqStack &S)
{
    if(S.base)
    {
        delete[] S.base;
        S.stacksize = 0;
        S.base = S.top = nullptr;
    }
}
~~~

***  
**2-链式栈**

*链式栈的定义*

~~~cpp
typedef struct StackNode
{
    ElemType data;
    StackNode *next;
} * LinkStack;
~~~

*栈的初始化*

~~~cpp
void InitStack(LinkStack &S)
{
    //创建头结点
    S = new StackNode;
    S->next = nullptr;
    S->data = 0; //表示栈的元素个数
}
//王老师的视频中没有设置头结点
//由于ELemType等价于int，因此我设置了一个头结点，在头结点的数据域中保存栈的元素个数
~~~

*压栈*

~~~cpp
void Push(LinkStack &S, const ElemType &e)
{
    //插入元素
    StackNode *temp = new StackNode;
    temp->data = e;
    temp->next = S->next;
    S->next = temp;
    ++(S->data);//元素个数加一
}
~~~

*弹栈*

~~~cpp
void Pop(LinkStack &S, ElemType &e)
{
    //删除元素
    StackNode *p = S->next;
    e = p->data;
    S->next = p->next;
    --(S->data);
    delete p;
}
~~~

*创建栈*

~~~cpp
void CreatStack(LinkStack &S, const int n)
{
    ElemType input;
    for (int i = 0; i < n;++i)
    {
        cin >> input;
        Push(S, input);
    }
}
~~~

*获取栈的元素个数*

~~~
int StackLength(LinkStack &S)
{
    return S->data;
}
~~~

*判断栈是否为空*

~~~cpp
bool IsEmpty(LinkStack &S)
{
    if(S->next)
    {
        return true;
    }
    else 
    {
        return false;
    }
}
~~~

*清空栈*

~~~cpp
bool ClearStack(LinkStack &S)
{
    if(!(S->next))
    {
        cerr << "empty Stack" << endl;
        return false;
    }
    StackNode *q, *p = S->next;
    while(p)
    {
        q = p;
        p = p->next;
        delete q;
    }
    S->data = 0;
    S->next = nullptr;
    return true;
}
~~~

*销毁链表*

~~~cpp
bool DestoryStack(LinkStack &S)
{
    if(S)
    {
        cerr << "error" << endl;
        return false;
    }
    while(S)
    {
        StackNode *temp = S;
        S = S->next;
        delete temp;
    }
    return true;
}
~~~


