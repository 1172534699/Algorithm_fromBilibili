**二叉树**

*二叉树的定义*

~~~cpp
struct BiNode
{
    ElemType data;
    BiNode *lchild, *rchild;
} *BiTree;
~~~

*二叉树的先序遍历 DLR*

~~~cpp
bool PreOrderTraverse(BiTree &T)
{
    if(T == nullptr)
    {
        return true;
    }
    //访问根结点
    visit(T);
    //递归遍历左孩子
    PreOrderTraverse(T->lchild);
    //递归遍历右孩子
    PreOrderTraverse(T->rchild);
    return true;
}
~~~

> 如何理解这个算法？通过画图，描述函数的调用时机，其实还是比较简单
>
> 以这个三结点的二叉树为例

*三结点二叉树*

![三结点二叉树图示](C:\Users\LJ\Desktop\images\image-20210204180903247.png)

*算法执行过程*

![先序遍历函数执行过程](https://github.com/IRVING-L/DataStruct_fromBilibili/images/image-20210204180551802.png)

*二叉树的先序遍历 LDR*

~~~cpp
bool InOrderTraverse(BiTree &T)
{
    if (T == nullptr)
    {
        return true;
    }
    //第一步：访问左孩子
    InOrderTraverse(T->lchild);
    //第二步：访问根结点
    visit(T);
    //第三步：访问右孩子
    InOrderTraverse(T->rchild);
    return true;
}
~~~

*二叉树的先序遍历 LRD*

~~~cpp 
bool PostOrderTraverse(BiTree &T)
{
    if (T == nullptr)
    {
        return true;
    }
    //第一步：访问左孩子
    PostOrderTraverse(T->lchild);
    //第二步：访问右孩子
    PostOrderTraverse(T->rchild);
    //第三步：访问根结点
    visit(T);
    return true;
}
~~~

> 三种算法的时间复杂度：O(n)，空间复杂度：O(n)
>
> 三种算法的思想都是DFS（深度优先算法）

*二叉树的中序遍历——非递归算法*

~~~cpp
void LDR(BiTree &T)
{
    //第一步：创建一个栈，用于保存二叉树的结点
    SqStack S;
    InitSqStack(S);
    BiTree p = T;
    while( p || !IsEmpty(S))
    {
        if(p)
        {
            Push(S, p);
            p = p->lchild;
        }
        else
        {
            Pop(S, p);
            visit(p);
            p = p->rchild;
        }
    }
}
~~~

*二叉树的层次遍历算法*

~~~cpp
void LevelOrder(BiTree &S)
{
    /*
    算法设计思路：
    1.将根结点入队
    2.队列不为空时循环，从队列中出列一个元素，访问它，并作以下步骤：
        2.1 如果该元素的左孩子不为空，让该元素的左孩子入队
        2.2 如果该元素的右孩子不为空，让该元素的右孩子入队
    */
    SqQueue Q;
    InitSqQueue(Q);

    BiTree p;
    PushQueue(Q, S);
    while (!QueueEmpty(Q))
    {
        //将根结点出队
        DeQueue(Q, p);
        //访问根结点
        cout << p->data << endl;
        //if判断，是否能将根结点的左右孩子进队
        if (p->lchild != nullptr)
        {
            PushQueue(Q, p->lchild);
        }
        if (p->rchild != nullptr)
        {
            PushQueue(Q, p->rchild);
        }
    }
}
~~~

***二叉树的建立（DLR先序遍历，递归算法）***

~~~cpp
bool CreatBiTree(BiTree &T)
{
    ElemType input;
    cin >> input;
    if(input == -1)//建立空结点的标志为 -1（这个自己设定一个就好）
        return false;
    T = new BiNode;
    //D
    T->data = input;
    //L
    CreatBiTree(T->lchild);
    //R
    CreatBiTree(T->rchild);
    return true;
}
~~~

*二叉树的复制*

~~~cpp
bool CopyBiTree(const BiTree &T, BiTree &NewT)
{
    if(T == nullptr)
    {
        return false;
    }
    NewT = new BiNode;
    //D
    NewT->data = T->data;
    //L
    CopyBiTree(T->lchild, NewT->lchild);
    //R
    CopyBiTree(T->rchild, NewT->rchild);
    return true;
}
~~~

*求二叉树的深度*

~~~cpp
int Depth(BiTree &T)
{
    if(T == nullptr)
    {
        return 0;
    }
    int m = Depth(T->lchild);
    int n = Depth(T->rchild);
    if(m>n)
        return m+1;
    else
        return n+1;
}
~~~

> ​	如何理解这个算法？
>
> 在我看来，二叉树的深度计算算法，是把二叉树的递归调用运用的淋漓尽致
>
> 首先，二叉树 = 根结点+左子树+右子树；右子树=根结点+左子树+右子树；左子树=根结点+左子树+右子树。。。如此循环反复，因此，我们对二叉树模型进行运算，只需要像剥洋葱一样，一层一层把二叉树剖开，把一个复杂二叉树的运算求解问题，分解成一个个的单结点二叉树（叶子结点）问题的累加，就会比较方便
>
> 这个深度计算算法，就是这个思想。用递归函数一层层分解二叉树，递归的到叶子结点。例如，当我们第一个叶子结点的的左孩子和右孩子都是空时，叶子结点的m和n都等于0，再通过一个if判断语句，让m和n中的较大值加1。也即叶子结点返回1，这个返回值就放在叶子结点的双亲的m中，再去看这个双亲的右孩子，循环反复，最后就能得到二叉树的深度。

*求二叉树的结点数*

~~~cpp
int CountNode(BiTree &T)
{
    if (T == nullptr)
    {
        return 0;
    }
    // //L
    // int m = CountNode(T->lchild);
    // //R
    // int n = CountNode(T->rchild);
    // //
    // return m + n + 1;
    //更加简单的语句
    return CountNode(T->lchild) + CountNode(T->rchild) + 1;
}
~~~

*求二叉树的叶子结点数*

~~~cpp
//王卓老师的视频范例
int Count0Node(BiTree &T)
{
    //③：递归函数将上一个结点剖分成左右子树，如果结点的孩子为空，那么返回0
    //这里不会出现结点的两个孩子都是空的，因为上一个结点执行这个递归函数的时候就已经判断了这种情况
    //这个语句只是为了以下两种情况而存在的：
    //1. 空树
    //2. 某个分支结点只有一个孩子
    if (T == nullptr)
    {
        return 0;
    }
    //①：其实呢，我们还是可以把这个问题拆分成左子树和右子树的统计问题
    if (T->lchild == nullptr && T->rchild == nullptr)
    {
        //以T为根结点的这棵树，左右孩子都没有，那他就是叶子结点
        return 1;
    }
    //②：如果不是这个情况，就说明这个根结点至少有一个孩子，还要继续剖分这个结点
    return Count0Node(T->lchild) + Count0Node(T->rchild);
}
~~~

~~~cpp
//我自己写的程序，确实有一点拉胯
/*
参数n：用于统计叶子结点数
参数flag：用于判断某个结点的两个孩子是否都为空
*/
bool Count0Node(BiTree &T, int &n, int &flag)
{
    if (T == nullptr)
    {
        flag = 1; //标志
        return false;
    }
    if (flag == 1)
    {
        ++n;
        flag = 0;
    }
    //L
    Count0Node(T->lchild, n, flag);
    //R
    Count0Node(T->rchild, n, flag);
    return true;
}
~~~

